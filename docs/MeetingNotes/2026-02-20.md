# Meeting Notes Feb 20, 2026

The purpose of this meeting was to review the design as discussed in issue #59.
##
Key points:

- I fixed the link in issue #59 to the [Design Overview](../tree/main/docs/Design/DesignOverview.md)
- In addition to the [Design Overview](../tree/main/docs/Design/DesignOverview.md), you may want to explore
- the code for `Builder<TRootArgs>.ParseArgs()`
  - All of the entry points use `ParseArgs` under the hood
  - It's access to data providers and the nested classes of the `Args` class illustrate use
- I want to better communicate the scope of each of the participating classes
  - `Builder<TRootArgs>()` contains transitory run information, and may eventually contain an optional cache for reentrancy  
  - `DataProvider<TRootArgs>` (will) contain only information that is static for that particular CLI, no run information
  - `CommandDataDefinition<TArgs>` contains non-provider and non-run specific definitions for the args
  - `DataValues<TActiveArgs>` contains run specific information
  - `Result<TRootArgs>` contains the hydrated Args class, the command line array (`args`) used, diagnostics, `DataValues<TActiveArgs>`, and optional debugging information
- Ubiquitous use of `TRootArgs` will segregate different CLIs trees in scenarios like a controlled repl that supports several CLI trees. Support is not planned for different CLI trees with the same root class
- Ubiquitous use of callbacks and `TValue` keep the values in their native type without boxing

What I should have shown and did not:

You can find the "generated" code in two ways:

- The `PrototypeConsoleApp` is what I use when I am working on the generator. I change that project until it compiles and runs, and only then adjust the generator. It can slip out of sync in details - naming, comments, code order, etc. When I get the chance, the project is now at the point for me to write tests to keep them in sync.
- To find the actual generated code, you need to build the project. `SampleConsoleApp` and `SubCommandConsoleApp` have project references, so you do not need to worry about packages to build, generate and run
  - Once you've built, if you're in Visual Studio, in Solution Explorer, open the project's Dependencies/Analyzers/DragonFruit2.Generators/DragonFruit2.Generators/DragonFruit2Generator
  
## Decisions

Came up during the meeting:

- Required should be part of validation, not separate. This decision will be reconsidered if we decide to validate the instance, because we can neither create the instance; or if we forced that, we cannot check required on the instance.
- The `Result` should be created before the data provider initialization and passed to it, in order to manage diagnostics

These are in the order of the checkboxes in #59

### Overall design

It was not practical for folks to see the design and immediately give feedback. I remain quite hungry for feedback on the design, and comments on issue #59 seems the best place. I'm happy to meet on complex or subtle questions.

### Nested classes

I continue to be of the opinion that we should use nested classes for generated code. @JeffHandley I'd particularly like your opinion on that. They limit the footprint in the user's `internal` surface area and avoid naming collisions. To look at them, someone has to find the generated code, so I have some confidence they are either advanced or brave.

### Args class naming

Note: this rarely appears in code, likely only as the base class (or interface) and constraint. It occurs massively in documentation and human facing communication, such as PRs and issues.

I think we are agreed we need a new name here, and I have not heard an alternative to it including "Command" as it parallels the concept of a command in CLIs (the union of command and branch in Spectre).

I do not think we should use the "Command" in that simple form. System.CommandLine and other parsers will almost certainly have a class of that name and there are times both concepts will appear in the same paragraph, even if that is not common.

I propose either `CommandDto`, `CliCommand` (that conflicts with a transitory name in S.CL) or similar. Be creative!

`CommandDataDefinition` is currently the name of one of the nested classes, and I had planned to simplify that to `CommandDefinition`, but it's not impossible for us to have `CommandDefinition` for the user's file, and `CommandDataDefinition` as the generated nested class.

Pretty please! weigh in on this. It's important we settle this because everyday I add several more occurrences or "Args class" in text.

### Managing constructor conflicts

Turns out this question is out of date. The generated constructor receives data values, and I think we can restrict the user to not doing that. The natural constructor for them to add takes values for use in testing. That's their choice. Eeek, they miss all DragonFruit2's goodness, and they could also get testing data via a mocking data provider.