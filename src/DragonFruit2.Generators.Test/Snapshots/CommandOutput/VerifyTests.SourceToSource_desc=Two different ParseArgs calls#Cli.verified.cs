//HintName: Cli.cs
// <auto-generated />
# nullable enable

using DragonFruit2;

/// <summary>
/// Auto-generated partial class that supplies the root ArgsBuilder type.
/// </summary>
public class Cli
{
    /// <summary>
    /// Advanced: Creates a Builder, which can be configured, the System.CommandLine API can be accessed, and which can be reused (especially helpful in testing). 
    /// </summary>
    /// <remarks>
    /// The args class specified as the type argument must be public.
    /// </remarks>
    /// <br/>
    /// <remarks>
    /// You may need to build after editing this line.
    /// </remarks>
    /// <typeparam name="TRootArgs">The type containing the CLI definition, the root command if there are subcommands.</typeparam>

    public static Builder<TRootArgs> CreateBuilder<TRootArgs>()
          where TRootArgs : ArgsRootBase<TRootArgs>
    {
        if (typeof(TRootArgs) == typeof(MyArgs))
        {
            var builder = new Builder<MyArgs>(new MyArgs.MyArgsDataDefinition(null, null));
            return builder is Builder<TRootArgs> typedBuilder
                  ? typedBuilder
                  : throw new InvalidOperationException("Type mismatch creating builder.");
        }
        if (typeof(TRootArgs) == typeof(MyOtherArgs))
        {
            var builder = new Builder<MyOtherArgs>(new MyOtherArgs.MyOtherArgsDataDefinition(null, null));
            return builder is Builder<TRootArgs> typedBuilder
                  ? typedBuilder
                  : throw new InvalidOperationException("Type mismatch creating builder.");
        }
        return null;
    }

    /// <summary>
    /// Parses CLI arguments to fill the specified args type.<br/>This method is generated specific to the type argument.<br/>You may need to build after editing.
    /// </summary>
    /// <remarks>
    /// The args class specified as the type argument must be public.
    /// </remarks>
    /// <typeparam name="TRootArgs">The type containing the CLI definition.</typeparam>
    /// <param name="args">Optionaly pass the commandline args, using the keyword `args`. If not passed, they will be retrieved for you.</param>

    public static Result<TRootArgs> ParseArgs<TRootArgs>(string[]? args = null)
          where TRootArgs : ArgsRootBase<TRootArgs>
    {
        return CreateBuilder<TRootArgs>().ParseArgs(args);
    }

    /// <summary>
    /// Attempts to parses CLI arguments and fill the specified args type.<br/>This method is generated specific to the type argument.<br/>You may need to build after editing.
    /// </summary>
    /// <remarks>
    /// The args class specified as the type argument must be public.
    /// </remarks>
    /// <typeparam name="TRootArgs">The type containing the CLI definition.</typeparam>
    /// <param name="result">An out parameter that contains an instance of the requested class and supporting data, such as diagnostics, a suggested CLI return value, etc.</param>
    /// <param name="args">Optionaly pass the commandline args, using the keyword `args`. If not passed, they will be retrieved for you.</param>
    /// <exception cref="InvalidOperationException">To be implemented soon.</param>

    public static bool TryParseArgs<TRootArgs>(out Result<TRootArgs> result, string[]? args = null)
          where TRootArgs : ArgsRootBase<TRootArgs>
    {
        result = ParseArgs<TRootArgs>(args);
        return result.IsValid;
    }
}
