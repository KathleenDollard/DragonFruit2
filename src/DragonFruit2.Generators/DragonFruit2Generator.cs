using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using DragonFruit2.GeneratorSupport;
using System.Text;

namespace DragonFruit2.Generators
{
    [Generator]
    public sealed partial class DragonFruit2Generator : IIncrementalGenerator
    {
        private static DragonFruit2Builder builder = new DragonFruit2Builder();

        private static int indentSize = 4;

        static CommandInfo Test2(GeneratorSyntaxContext ctx)
        {
            var classDeclaration = (ctx.Node as ClassDeclarationSyntax);
            if (classDeclaration == null)
                return null;
            var name = classDeclaration?.Identifier.ValueText;
            return new CommandInfo() { Name = name };
        }

        //bool CheckAttribute(SyntaxNode node) { 
        //    return node.GetAttributeValue() }


        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // invocation expressions whose name is "ParseArgs" with a single generic type argument.
            var parseArgsInvocations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => builder.InitialFilter (node),
                    transform: static (ctx, _) => builder.Transform(ctx))
                .WithTrackingName("ParseArgsInvocations")
                .Where(static s => s is not null)
                .Select(static (s, _) => s!)
                .Collect();

            context.RegisterSourceOutput(parseArgsInvocations, static (spc, collected) =>
            {
                foreach (var commandInfo in collected)
                {
                    var sourceText = GetSourceForCommandInfo(commandInfo);
                    spc.AddSource($"{commandInfo.Name}_ParseArgsGenerator.g.cs", sourceText);
                }

            });
        }

        internal static string GetSourceForCommandInfo(CommandInfo commandInfo)
        {
            var description = commandInfo.Description is null
                                  ? "null"
                                  : $"\"{commandInfo.Description.Replace("\"", "\"\"")}\"";

            var sb = new StringBuilder();
            sb.Append($$"""
                       // <auto-generated />
                       using DragonFruit2;
                       using System.CommandLine;
       
                       namespace {{commandInfo.NamespaceName}}
                       {
                           public partial class {{commandInfo.Name}} : IArgs<{{commandInfo.Name}}>
                           {
                               public static System.CommandLine.Command CreateCli()
                               {
                                   var rootCommand = new System.CommandLine.Command("Test")
                                       {
                                           Description = {{ description }}
                                       };
                       """);
            foreach (var option in commandInfo.Options)
            {
                GetOptionDeclaration(sb, option);
            }
            foreach (var argument in commandInfo.Arguments)
            {
                GetArgumentDeclaration(sb, argument);
            }
            foreach (var subcommand in commandInfo.SubCommands)
            {
                GetSubCommandDeclaration(sb, subcommand);
            }
            sb.AppendLine();
            sb.Append($$"""
                                   return rootCommand;
                               }
                       """);
            sb.AppendLine();
            sb.AppendLine();
            sb.Append($$"""
                               public static {{commandInfo.Name}} Create(ParseResult parseResult)
                               {
                                   var newArgs = new {{commandInfo.Name}}()
                                   {
                                   };
                                   return newArgs;
                               }
                           }
                       }
                       """);
            return sb.ToString();
        }

        internal static void GetSubCommandDeclaration(StringBuilder sb, CommandInfo commandInfo)
        {
            sb.Append($$"""
                                   commandInfo.Add(new System.CommandLine.Command("Test")              
                                   {
                                       Description = { { description } }
                                   };
                       """);
            foreach (var option in commandInfo.Options)
            {
                GetOptionDeclaration(sb, option);
            }
            foreach (var argument in commandInfo.Arguments)
            {
                GetArgumentDeclaration(sb, argument);
            }
            foreach (var subcommand in commandInfo.SubCommands)
            {
                GetSubCommandDeclaration(sb, subcommand);
            }
        }

        private static void GetArgumentDeclaration(StringBuilder sb, PropInfo propInfo)
        {
            var description = propInfo.Description is null
                                  ? "null"
                                  : $"\"{propInfo.Description.Replace("\"", "\"\"")}\"";
            sb.Append($$"""
                rootCommand.Add(new Argument<{{propInfo.TypeName}}>("{{propInfo.Name}}")
                {
                    Description = {{description}},
                    Required = {{(propInfo.IsRequiredForCli ? "true" : "false")}}
                });
                """);
        }

        internal static void GetOptionDeclaration(StringBuilder sb, PropInfo propInfo)
        {
            var description = propInfo.Description is null
                                  ? "null"
                                  : $"\"{propInfo.Description.Replace("\"", "\"\"")}\"";
            sb.Append($$"""
                rootCommand.Add(new Option<{{propInfo.TypeName}}>("--{{propInfo.CliName}}")
                {
                    Description = {{description}},
                    Required = {{(propInfo.IsRequiredForCli ? "true" : "false")}}
                });
                """);
        }

        internal static bool IsPotentialParseArgsInvocation(SyntaxNode node)
              => (node is InvocationExpressionSyntax inv) &&
                  inv.Expression switch
                  {
                      MemberAccessExpressionSyntax ma when ma.Name is GenericNameSyntax gns
                          => gns.Identifier.ValueText == "ParseArgs" && gns.TypeArgumentList.Arguments.Count == 1,
                      GenericNameSyntax gns2
                          => gns2.Identifier.ValueText == "ParseArgs" && gns2.TypeArgumentList.Arguments.Count == 1,
                      _ => false,
                  };

        internal static CommandInfo? GetRootCommandInfo(GeneratorSyntaxContext ctx) =>
            // We only get here for ParseArg invocations with a single generic type argument
            ctx.Node switch
            {
                InvocationExpressionSyntax invocationSyntax
                                   => GetRootCommandInfoFromInvocation(invocationSyntax, ctx.SemanticModel),
                _ => null,
            };

        internal static CommandInfo? GetRootCommandInfoFromInvocation(InvocationExpressionSyntax invocationSyntax, SemanticModel semanticModel)
        {
            var rootArgTypeArgSymbol = GetArgTypeSymbol(invocationSyntax, semanticModel);
            if (rootArgTypeArgSymbol is null)
                return null; // This occurs when the root arg type does not yet exist
            var rootCommandInfo = CreateCommandInfo(rootArgTypeArgSymbol, semanticModel);
            return rootCommandInfo;
        }


        internal static CommandInfo CreateCommandInfo(INamedTypeSymbol typeSymbol, SemanticModel semanticModel)
        {

            var commandInfo = CommandInfoHelpers.CreateCommandInfo(typeSymbol);

            var props = typeSymbol.GetMembers()
                                  .OfType<IPropertySymbol>()
                                  .Where(p => !p.IsStatic)
                                  .Select(p => CommandInfoHelpers.CreatePropInfo(p))
                                  .ToList();

            // Split into argument list and options
            var argList = props.Where(p => p.IsArgument).OrderBy(p => p.Position).ToList();
            var optList = props.Where(p => !p.IsArgument).ToList();
            commandInfo.Arguments.AddRange(argList);
            commandInfo.Options.AddRange(optList);

            var compilation = semanticModel.Compilation;

            var derivedTypes = GetChildTypes(typeSymbol);
            foreach (var derivedType in derivedTypes)
            {
                var childCommandInfo = CreateCommandInfo(derivedType, semanticModel);
                commandInfo.SubCommands.Add(childCommandInfo);
            }

            return commandInfo;
        }

        internal static IEnumerable<INamedTypeSymbol> GetChildTypes(INamedTypeSymbol typeSymbol)
        {
            var derivedTypes = new List<INamedTypeSymbol>();
            var nspace = typeSymbol.ContainingNamespace;
            foreach (var member in nspace.GetMembers())
            {
                if (member is INamedTypeSymbol namedTypeSymbol)
                {
                    // Check if this type derives from the given typeSymbol
                    if (SymbolEqualityComparer.Default.Equals(namedTypeSymbol.BaseType, typeSymbol))
                    {
                        // This namedTypeSymbol derives from typeSymbol
                        derivedTypes.Add(namedTypeSymbol.BaseType);
                        break;
                    }
                }
            }
            return derivedTypes;
        }

        internal static INamedTypeSymbol? GetArgTypeSymbol(InvocationExpressionSyntax? invocation, SemanticModel semanticModel)
        {
            if (invocation is null) return null;

            GenericNameSyntax? genericName = invocation.Expression switch
            {
                MemberAccessExpressionSyntax ma when ma.Name is GenericNameSyntax gns
                    => gns,
                GenericNameSyntax gns
                    => gns,
                _ => null,
            };

            if (genericName is null) return null;

            var typeArgSyntax = genericName.TypeArgumentList.Arguments[0];

            return semanticModel.GetSymbolInfo(typeArgSyntax).Symbol as INamedTypeSymbol;
        }



        static bool HasPartialDeclaration(INamedTypeSymbol typeSymbol)
        {
            foreach (var decl in typeSymbol.DeclaringSyntaxReferences)
            {
                var node = decl.GetSyntax();
                if (node is TypeDeclarationSyntax tds)
                {
                    if (tds.Modifiers.Any(m => m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.PartialKeyword)))
                        return true;
                }
            }
            return false;
        }

        //static string GenerateForType(INamedTypeSymbol typeSymbol)
        //{
        //    var ns = GetNamespace(typeSymbol);
        //    var accessibility = typeSymbol.DeclaredAccessibility switch
        //    {
        //        Accessibility.Public => "public",
        //        Accessibility.public => "public",
        //        Accessibility.Protected => "protected",
        //        Accessibility.ProtectedOrpublic => "protected public",
        //        _ => "public",
        //    };

        //    var typeNameWithArity = typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        //    // Collect property symbols (instance)
        //    var commandInfo = CommandInfo.GetCommandInfo(typeSymbol);
        //    var argList = commandInfo.Arguments.OrderBy(x => x.Position).ToList();
        //    var optList = commandInfo.Options.OrderBy(x => x.Name).ToList();

        //    var sb = new StringBuilder();
        //    sb.AppendLine("// <auto-generated />");
        //    sb.AppendLine("using System;");
        //    sb.AppendLine("using System.CommandLine;");
        //    sb.AppendLine("using System.CommandLine.Parsing;");
        //    sb.AppendLine();

        //    if (!string.IsNullOrEmpty(ns))
        //    {
        //        sb.AppendLine($"namespace {ns}");
        //        sb.AppendLine("{");
        //    }

        //    var indentLevel = string.IsNullOrEmpty(ns) ? 0 : 1;
        //    var indentStr = new string(' ', indentLevel * indentSize);

        //    sb.AppendLine($"{indentStr}{accessibility} partial class {typeSymbol.Name} : global::DragonFruit2.IArgs<{typeNameWithArity}>");
        //    sb.AppendLine($"{indentStr}{{");

        //    // CreateCli static method - build Command using compile-time information
        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize)}public static global::System.CommandLine.Command CreateCli()");
        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize)}{{");

        //    // Use class name as command name (lowercase)
        //    var commandNameLiteral = EscapeStringLiteral(typeSymbol.Name.ToLowerInvariant());
        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}var command = new global::System.CommandLine.Command(\"{commandNameLiteral}\");");
        //    sb.AppendLine();

        //    // Add arguments
        //    foreach (var a in argList)
        //    {
        //        var varName = $"arg_{a.Name}";
        //        var argName = EscapeStringLiteral(a.Name.ToLowerInvariant());
        //        var typeName = a.TypeName;
        //        var desc = EscapeStringLiteral(a.Description ?? string.Empty);

        //        // Determine arity based on required flag and whether the property has initializer
        //        var (min, max) = a.IsRequiredForCli ? (1, 1) : (0, 1);

        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}var {varName} = new global::System.CommandLine.Argument<{typeName}>(\"{argName}\")");
        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}{{");
        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 3)}Description = \"{desc}\",");
        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 3)}Arity = new ArgumentArity({min}, {max})");
        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}}};");

        //        if (a.HasInitializer)
        //        {
        //            // annotate with comment indicating default value found in source
        //            sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}// default value in declaration: {EscapeStringLiteral(a.InitializerText ?? string.Empty)}");
        //        }

        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}command.Add({varName});");
        //        sb.AppendLine();
        //    }

        //    // Add options
        //    foreach (var o in optList)
        //    {
        //        var varName = $"opt_{o.Name}";
        //        var kebab = ToKebabCase(o.Name);
        //        var optNameLiteral = EscapeStringLiteral($"--{kebab}");
        //        var typeName = o.TypeName;
        //        var desc = EscapeStringLiteral(o.Description ?? string.Empty);
        //        var requiredLiteral = o.IsRequiredForCli ? "true" : "false";

        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}var {varName} = new global::System.CommandLine.Option<{typeName}>(\"{optNameLiteral}\")");
        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}{{");
        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 3)}Description = \"{desc}\",");
        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 3)}Required = {requiredLiteral}");
        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}}};");

        //        if (o.HasInitializer)
        //        {
        //            sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}// default value in declaration: {EscapeStringLiteral(o.InitializerText ?? string.Empty)}");
        //            // We do not attempt to emit API-specific default wiring here (avoid runtime API mismatch),
        //            // but a presence of initializer makes the option optional (Required=false) above.
        //        }

        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}command.Add({varName});");
        //        sb.AppendLine();
        //    }

        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}return command;");
        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize * indentSize)} }}");
        //    sb.AppendLine();

        //    // Create static factory wrapper
        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize)}public static {typeNameWithArity} Create(ParseResult parseResult)");
        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize)}    => global::DragonFruit2.CommandLineBinding.BindResult<{typeNameWithArity}>(parseResult);");
        //    sb.AppendLine();

        //    // SetParsedValues instance method - assign each property from bound instance
        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize)}public void SetParsedValues(ParseResult result)");
        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize)}{{");
        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}var bound = global::DragonFruit2.CommandLineBinding.BindResult<{typeNameWithArity}>(result);");
        //    foreach (var option in optList)
        //    {
        //        sb.AppendLine($"{indentStr}{GetBindingString(option)}");
        //    }

        //    foreach (var arg in argList)
        //    {
        //        sb.AppendLine($"{indentStr}{new string(' ', indentSize * 2)}this.{arg.Name} = parseResult.GetValue<{arg.TypeName}>({arg.CliName});");
        //    }

        //    sb.AppendLine($"{indentStr}{new string(' ', indentSize)} }}");

        //    sb.AppendLine("}");

        //    if (!string.IsNullOrEmpty(ns))
        //    {
        //        sb.AppendLine("}");
        //    }

        //    return sb.ToString();
        //}

        //private static string GetBindingString(PropInfo propInfo)
        //{
        //    return $"{new string(' ', indentSize * 2)}this.{propInfo.Name} = parseResult.GetValue<{propInfo.TypeName}>({propInfo.CliName});";
        //}


        //static string EscapeStringLiteral(string s)
        //{
        //    if (s is null) return string.Empty;
        //    return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    //}
}
