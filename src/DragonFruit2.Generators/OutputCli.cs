namespace DragonFruit2.Generators;

// The Cli uses a trick base on C# overload resolution behavior. Items in the current namespace have precedence over those in imported namespaces.
// When the user initially creates the app, importing DragonFruit2 supplies a CLI class for IntelliSense. When generation occurs, this call
// is replaced with the generated CLI. This design allows access to the RootArgsBuilder without complicating user code. In modern .NET, this 
// could also be done with a static interface method. However, old .NET Framework...
public class OutputCli
{
    internal static string GetSource(IEnumerable<CommandInfo> commandInfos)
    {
        var rootCommandInfos = commandInfos
                .Where(c => c.ParentCommandInfo == null);
        var cliNamespace = rootCommandInfos
                .First()
                .CliNamespaceName;
        var argsNamespaces = rootCommandInfos
                .Select(c => c.NamespaceName)
                .Distinct()
                .ToArray();
        var sb = new StringBuilderWrapper();
        FileOpening(sb, cliNamespace, argsNamespaces);
        sb.OpenNamespace(cliNamespace);


        OpenClass( sb);
        CreateBuilder(rootCommandInfos, sb);
        ParseArgsMethod( sb);
        TryParseArgsMethod( sb);
        //TryExecute(commandInfo, sb);

        sb.CloseClass();
        sb.CloseNamespace(cliNamespace);
        return sb.ToString();
    }

    private static void FileOpening(StringBuilderWrapper sb, string? cliNamespace, string?[] argsNamespaces)
    {
        sb.AppendLines([
                       "// <auto-generated />",
                       "# nullable enable",
                       "",
                       "using DragonFruit2;"]);
        // This is necessary when the RootArgs is not in the same namespace as the call to `Cli.TryParse`, such as top-level statements 
        foreach (var argsNamespace in argsNamespaces)
        {
            if (!string.IsNullOrEmpty(argsNamespace) && cliNamespace != argsNamespace)
            {
                sb.AppendLine($"using {argsNamespace};");
            }
        }
    }

    internal static void OpenClass(StringBuilderWrapper sb)
    {
        sb.AppendLines([
                "/// <summary>",
                $"""/// Auto-generated partial class that supplies the root ArgsBuilder type.""",
                "/// </summary>",
                $"public class Cli"]);
        sb.OpenCurly();
    }

    private static void CreateBuilder(IEnumerable<CommandInfo> rootCommandInfos, StringBuilderWrapper sb)
    {

        sb.XmlSummary("Advanced: Creates a Builder, which can be configured, the System.CommandLine API can be accessed, and which can be reused (especially helpful in testing). ");
        sb.XmlRemarks("The args class specified as the type argument must be public.");
        sb.XmlBreak();
        sb.XmlRemarks("You may need to build after editing this line.");
        sb.XmlTypeParam("TRootArgs", "The type containing the CLI definition, the root command if there are subcommands.");

        sb.OpenMethod($"public static Builder<TRootArgs> CreateBuilder<TRootArgs>()", "TRootArgs : ArgsRootBase<TRootArgs>");

        foreach (var rootCommandInfo in rootCommandInfos)
        {
            var rootName = rootCommandInfo.Name;
            sb.OpenIf($"typeof(TRootArgs) == typeof({rootName})");
            sb.AppendLine($"var builder = new Builder<{rootName}>(new {rootName}.{rootName}ArgsBuilder(null, null));");
            sb.AppendLines([$"return builder is Builder<TRootArgs> typedBuilder",
            "      ? typedBuilder",
            "      : throw new InvalidOperationException(\"Type mismatch creating builder.\");"]);
            sb.CloseIf();
        }

        // TODO: Switch to a compilation generator and add all root args here.

        sb.Return("null");
        sb.CloseMethod();
        sb.AppendLine();
    }
    private static void ParseArgsMethod(StringBuilderWrapper sb)
    {
        sb.XmlSummary("Parses CLI arguments to fill the specified args type.<br/>This method is generated specific to the type argument.<br/>You may need to build after editing.");
        sb.XmlRemarks("The args class specified as the type argument must be public.");
        sb.XmlTypeParam("TRootArgs", "The type containing the CLI definition.");
        sb.XmlParam("args", "Optionaly pass the commandline args, using the keyword `args`. If not passed, they will be retrieved for you.");

        sb.OpenMethod($"public static Result<TRootArgs> ParseArgs<TRootArgs>(string[]? args = null)",
            constraints: $"TRootArgs : ArgsRootBase<TRootArgs>");
        sb.AppendLine($"return CreateBuilder<TRootArgs>().ParseArgs(args);");
        sb.CloseMethod();
        sb.AppendLine();
    }

    private static void TryParseArgsMethod( StringBuilderWrapper sb)
    {
        sb.XmlSummary("Attempts to parses CLI arguments and fill the specified args type.<br/>This method is generated specific to the type argument.<br/>You may need to build after editing.");
        sb.XmlRemarks("The args class specified as the type argument must be public.");
        sb.XmlTypeParam("TRootArgs", "The type containing the CLI definition.");
        sb.XmlParam("result", "An out parameter that contains an instance of the requested class and supporting data, such as diagnostics, a suggested CLI return value, etc.");
        sb.XmlParam("args", "Optionaly pass the commandline args, using the keyword `args`. If not passed, they will be retrieved for you.");
        sb.XmlException("InvalidOperationException", "To be implemented soon.");

        sb.OpenMethod($"public static bool TryParseArgs<TRootArgs>(out Result<TRootArgs> result, string[]? args = null)",
            constraints: $"TRootArgs : ArgsRootBase<TRootArgs>");

        sb.AppendLine($"result = ParseArgs<TRootArgs>(args);");
        sb.Return("result.IsValid");
        sb.CloseMethod();
    }
}

